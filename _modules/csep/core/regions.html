

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>csep.core.regions &mdash; PyCSEP v0.4.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <!-- Google Analytics -->
    <!-- added options to anonymize ip and disable cookies using {'storage': 'none'} 
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-495056-15', 'auto', {'storage': 'none'});
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
    </script> -->

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> PyCSEP
          

          
          </a>

          
            
            
              <div class="version">
                v0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/installing.html">Installing PyCSEP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/core_concepts.html">Core Concepts for Beginners</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials and Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_filtering.html">Catalogs operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_gridded_forecast.html">Plotting gridded forecast</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/gridded_forecast_evaluation.html">Grid-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/working_with_catalog_forecasts.html">Working with catalog-based forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/catalog_forecast_evaluation.html">Catalog-based Forecast Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/plot_customizations.html">Plot customizations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/catalogs.html">Catalogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/forecasts.html">Forecasts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/evaluations.html">Evaluations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/regions.html">Regions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Help &amp; Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/glossary.html">Terms and Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/publications.html">Referenced Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/roadmap.html">Development Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/developer_notes.html">Developer Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api_reference.html">API Reference</a></li>
</ul>

            
          

    
        <p class="caption">
            <span class="caption-text">Source code and contributing</span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/csep2/blob/dev/CONTRIBUTING.md">Contributing</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/csep2/blob/dev/CODE_OF_CONDUCT.md">Code of Conduct</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/csep2/blob/dev/LICENSE">License</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/csep2/issues">Getting help</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/SCECCode/csep2">Source Code</a></li>
            
        </ul>
    

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PyCSEP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../csep.html">csep</a> &raquo;</li>
        
      <li>csep.core.regions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for csep.core.regions</h1><div class="highlight"><pre>
<span></span><span class="c1"># Python imports</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">compress</span>
<span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="c1"># Third-party imports</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyproj</span>

<span class="c1"># PyCSEP imports</span>
<span class="kn">from</span> <span class="nn">csep.utils.calc</span> <span class="kn">import</span> <span class="n">bin1d_vec</span><span class="p">,</span> <span class="n">cleaner_range</span><span class="p">,</span> <span class="n">first_nonnan</span><span class="p">,</span> <span class="n">last_nonnan</span>
<span class="kn">from</span> <span class="nn">csep.utils.scaling_relationships</span> <span class="kn">import</span> <span class="n">WellsAndCoppersmith</span>

<span class="k">def</span> <span class="nf">california_relm_collection_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;relm-california-collection&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return collection region for California RELM testing region</span>

<span class="sd">        Args:</span>
<span class="sd">            dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">            mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">            name (str): human readable identifer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;RELMCollectionArea.dat&#39;</span><span class="p">)</span>
    <span class="n">midpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">origins</span> <span class="o">=</span> <span class="n">midpoints</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">relm_region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

    <span class="k">return</span> <span class="n">relm_region</span>

<div class="viewcode-block" id="california_relm_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.california_relm_region.html#csep.core.regions.california_relm_region">[docs]</a><span class="k">def</span> <span class="nf">california_relm_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;relm-california&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns class representing California testing region.</span>

<span class="sd">    This region can</span>
<span class="sd">    be used to create gridded datasets for earthquake forecasts. The XML file appears to use the</span>
<span class="sd">    midpoint, and the .dat file uses the origin in the &quot;lower left&quot; corner.</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_scale: can resample this grid by factors of 2</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

        <span class="c1"># use default file path from python package</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;csep-forecast-template-M5.xml&#39;</span><span class="p">)</span>
    <span class="n">csep_template</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">midpoints</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">parse_csep_template</span><span class="p">(</span><span class="n">csep_template</span><span class="p">)</span>
    <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">relm_region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

    <span class="k">return</span> <span class="n">relm_region</span></div>

<div class="viewcode-block" id="italy_csep_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.italy_csep_region.html#csep.core.regions.italy_csep_region">[docs]</a><span class="k">def</span> <span class="nf">italy_csep_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-italy&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns class representing Italian testing region.</span>

<span class="sd">        This region can be used to create gridded datasets for earthquake forecasts. The region is defined by the</span>
<span class="sd">        file &#39;forecast.italy.M5.xml&#39; and contains a spatially gridded region with 0.1° x 0.1° cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            dh_scale: can resample this grid by factors of 2</span>
<span class="sd">            magnitudes (array-like): bin edges for magnitudes. if provided, will be bound to the output region class.</span>
<span class="sd">                                     this argument provides a short-cut for creating space-magnitude regions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`csep.core.spatial.CartesianGrid2D`</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: dh_scale must be a factor of two</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

        <span class="c1"># use default file path from python package</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;forecast.italy.M5.xml&#39;</span><span class="p">)</span>
    <span class="n">csep_template</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">midpoints</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">parse_csep_template</span><span class="p">(</span><span class="n">csep_template</span><span class="p">)</span>
    <span class="n">origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">italy_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">italy_region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

    <span class="k">return</span> <span class="n">italy_region</span></div>

<span class="k">def</span> <span class="nf">italy_csep_collection_region</span><span class="p">(</span><span class="n">dh_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;csep-italy-collection&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return collection region for Italy CSEP collection region</span>

<span class="sd">        Args:</span>
<span class="sd">            dh_scale (int): factor of two multiple to change the grid size</span>
<span class="sd">            mangitudes (array-like): array representing the lower bin edges of the magnitude bins</span>
<span class="sd">            name (str): human readable identifer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dh_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_scale must be a factor of two or dh_scale must equal unity.&quot;</span><span class="p">)</span>

    <span class="c1"># we can hard-code the dh because we hard-code the filename</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)))</span>
    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s1">&#39;artifacts&#39;</span><span class="p">,</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span> <span class="s1">&#39;italy.collection.nodes.dat&#39;</span><span class="p">)</span>
    <span class="n">midpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">origins</span> <span class="o">=</span> <span class="n">midpoints</span> <span class="o">-</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">dh_scale</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">origins</span> <span class="o">=</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dh_scale</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="n">dh_scale</span>

    <span class="c1"># turn points into polygons and make region object</span>
    <span class="n">bboxes</span> <span class="o">=</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">relm_region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">relm_region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>

    <span class="k">return</span> <span class="n">relm_region</span>

<div class="viewcode-block" id="global_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.global_region.html#csep.core.regions.global_region">[docs]</a><span class="k">def</span> <span class="nf">global_region</span><span class="p">(</span><span class="n">dh</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a global region used for evaluating gridded forecasts on the global scale.</span>

<span class="sd">    The gridded region corresponds to the</span>

<span class="sd">    Args:</span>
<span class="sd">        dh:</span>

<span class="sd">    Returns:</span>
<span class="sd">        csep.utils.CartesianGrid2D:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># generate latitudes</span>

    <span class="n">lons</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="o">-</span><span class="mf">180.0</span><span class="p">,</span> <span class="mf">179.9</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">lats</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="mf">89.9</span><span class="p">,</span> <span class="n">dh</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span><span class="n">lats</span><span class="p">)</span>
    <span class="n">region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">dh</span><span class="p">)],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>
    <span class="k">return</span> <span class="n">region</span></div>

<div class="viewcode-block" id="magnitude_bins"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.magnitude_bins.html#csep.core.regions.magnitude_bins">[docs]</a><span class="k">def</span> <span class="nf">magnitude_bins</span><span class="p">(</span><span class="n">start_magnitude</span><span class="p">,</span> <span class="n">end_magnitude</span><span class="p">,</span> <span class="n">dmw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns array holding magnitude bin edges.</span>

<span class="sd">    The output from this function is monotonically increasing and equally spaced bin edges that can represent magnitude</span>
<span class="sd">    bins.</span>

<span class="sd">     Args:</span>
<span class="sd">        start_magnitude (float)</span>
<span class="sd">        end_magnitude (float)</span>
<span class="sd">        dmw (float): magnitude spacing</span>

<span class="sd">    Returns:</span>
<span class="sd">        bin_edges (numpy.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to integers to prevent accumulating floating point errors</span>
    <span class="n">const</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">const</span> <span class="o">*</span> <span class="n">start_magnitude</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">const</span> <span class="o">*</span> <span class="n">end_magnitude</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">dmw</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">const</span></div>

<div class="viewcode-block" id="create_space_magnitude_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.create_space_magnitude_region.html#csep.core.regions.create_space_magnitude_region">[docs]</a><span class="k">def</span> <span class="nf">create_space_magnitude_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">magnitudes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple wrapper to create space-magnitude region &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">CartesianGrid2D</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;region must be CartesianGrid2D&quot;</span><span class="p">)</span>
    <span class="c1"># bind to region class</span>
    <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;magnitudes should not be None if creating space-magnitude region.&quot;</span><span class="p">)</span>
    <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>
    <span class="n">region</span><span class="o">.</span><span class="n">num_mag_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">region</span></div>

<div class="viewcode-block" id="parse_csep_template"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.parse_csep_template.html#csep.core.regions.parse_csep_template">[docs]</a><span class="k">def</span> <span class="nf">parse_csep_template</span><span class="p">(</span><span class="n">xml_filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads CSEP XML template file and returns the lat/lon values</span>
<span class="sd">    for the forecast.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of tuples where tuple is (lon, lat)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">xml_filename</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}cell&#39;</span><span class="p">):</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">])))</span>

    <span class="c1"># get cell spacing</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}forecastData&#39;</span><span class="p">)</span>
    <span class="n">dh_elem</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;{http://www.scec.org/xml-ns/csep/forecast/0.1}defaultCellDimension&#39;</span><span class="p">)</span>
    <span class="n">dh_lat</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_elem</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;latRange&#39;</span><span class="p">])</span>
    <span class="n">dh_lon</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dh_elem</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;lonRange&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dh_lat</span><span class="p">,</span> <span class="n">dh_lon</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dh_lat must equal dh_lon. grid needs to be regular.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">dh_lat</span></div>

<div class="viewcode-block" id="increase_grid_resolution"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.increase_grid_resolution.html#csep.core.regions.increase_grid_resolution">[docs]</a><span class="k">def</span> <span class="nf">increase_grid_resolution</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a set of origin points and returns a new set with higher grid resolution. assumes the origin point is in the</span>
<span class="sd">    lower left corner. the new dh is dh / factor. This implementation requires that the decimation factor be a multiple of 2.</span>

<span class="sd">    Args:</span>
<span class="sd">        points: list of (lon,lat) tuples</span>
<span class="sd">        dh: old grid spacing</span>
<span class="sd">        factor: amount to reduce</span>

<span class="sd">    Returns:</span>
<span class="sd">        points: list of (lon,lat) tuples with spacing dh / scale</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># short-circuit recursion</span>
    <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">points</span>

    <span class="c1"># handle edge cases</span>
    <span class="k">assert</span> <span class="n">factor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;=</span> <span class="mi">1</span>

    <span class="c1"># first start out</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">new_dh</span> <span class="o">=</span> <span class="n">dh</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">compute_vertex</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">new_dh</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">bbox</span><span class="p">:</span>
            <span class="n">new_points</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
    <span class="c1"># call function again with new_points, new_dh, new_factor</span>
    <span class="n">new_factor</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">increase_grid_resolution</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_points</span><span class="p">),</span> <span class="n">new_dh</span><span class="p">,</span> <span class="n">new_factor</span><span class="p">)</span></div>

<div class="viewcode-block" id="masked_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.masked_region.html#csep.core.regions.masked_region">[docs]</a><span class="k">def</span> <span class="nf">masked_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">polygon</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a new region based off the coordinates in the polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        region: CartesianGrid2D object</span>
<span class="sd">        polygon: Polygon object</span>

<span class="sd">    Returns:</span>
<span class="sd">        new_region: CartesianGrid2D object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># contains is true if spatial cell in region is inside the polygon</span>
    <span class="n">contains</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">midpoints</span><span class="p">())</span>
    <span class="c1"># compress only returns elements that are true, effectively removing elements outside of the polygons</span>
    <span class="n">new_polygons</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compress</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">polygons</span><span class="p">,</span> <span class="n">contains</span><span class="p">))</span>
    <span class="c1"># create new region with the spatial cells inside the polygon</span>
    <span class="k">return</span> <span class="n">CartesianGrid2D</span><span class="p">(</span><span class="n">new_polygons</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span></div>

<div class="viewcode-block" id="generate_aftershock_region"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.generate_aftershock_region.html#csep.core.regions.generate_aftershock_region">[docs]</a><span class="k">def</span> <span class="nf">generate_aftershock_region</span><span class="p">(</span><span class="n">mainshock_mw</span><span class="p">,</span> <span class="n">mainshock_lon</span><span class="p">,</span> <span class="n">mainshock_lat</span><span class="p">,</span> <span class="n">num_radii</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">california_relm_region</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a spatial region around a given epicenter</span>

<span class="sd">    The method uses the Wells and Coppersmith scaling relationship to determine the average fault length and creates a</span>
<span class="sd">    circular region centered at (mainshock_lon, mainshock_lat) with radius = num_radii.</span>

<span class="sd">    Args:</span>
<span class="sd">        mainshock_mw (float): magnitude of mainshock</span>
<span class="sd">        mainshock_lon (float): epicentral longitude</span>
<span class="sd">        mainshock_lat (float): epicentral latitude</span>
<span class="sd">        num_radii (float/int): number of radii of circular region</span>
<span class="sd">        region (callable): returns :class:`csep.utils.spatial.CartesianGrid2D`</span>
<span class="sd">        **kwargs (dict): passed to region callable</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`csep.utils.spatial.CartesianGrid2D`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rupture_length</span> <span class="o">=</span> <span class="n">WellsAndCoppersmith</span><span class="o">.</span><span class="n">mag_length_strike_slip</span><span class="p">(</span><span class="n">mainshock_mw</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
    <span class="n">aftershock_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="o">.</span><span class="n">from_great_circle_radius</span><span class="p">((</span><span class="n">mainshock_lon</span><span class="p">,</span> <span class="n">mainshock_lat</span><span class="p">),</span>
                                                          <span class="n">num_radii</span> <span class="o">*</span> <span class="n">rupture_length</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">aftershock_region</span> <span class="o">=</span> <span class="n">masked_region</span><span class="p">(</span><span class="n">region</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">aftershock_polygon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">aftershock_region</span></div>

<span class="k">def</span> <span class="nf">grid_spacing</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Figures out the length and</span>

<span class="sd">    Args:</span>
<span class="sd">        vertices: Vertices describe a single node in grid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dh: grid spacing</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get first two vertices</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># compute both differences, because unless point is the same one is bound to be the dh</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;grid spacing must be regular for cartesian grid.&quot;</span><span class="p">)</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">])</span>
    <span class="c1"># this would happen if the same point is repeated twice</span>
    <span class="k">if</span> <span class="n">dh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Problem computing grid spacing cannot be zero.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dh</span>

<span class="k">def</span> <span class="nf">compute_vertex</span><span class="p">(</span><span class="n">origin_point</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the bounding box of a rectangular polygon given its origin points and spacing dh.</span>

<span class="sd">    Args:</span>
<span class="sd">        origin_points: list of tuples, where tuple is (x, y)</span>
<span class="sd">        dh: spacing</span>
<span class="sd">        tol: used to eliminate overlapping polygons in the case of a rectangular mesh, defaults to</span>
<span class="sd">             the machine tolerance.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of polygon edges</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="p">((</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">),</span>
            <span class="p">(</span><span class="n">origin_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dh</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">origin_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">bbox</span>

<span class="k">def</span> <span class="nf">compute_vertices</span><span class="p">(</span><span class="n">origin_points</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper function to compute vertices for multiple points. Default tolerance is set to machine precision</span>
<span class="sd">    of floating point number.</span>

<span class="sd">    Args:</span>
<span class="sd">        origin_points: 2d ndarray</span>

<span class="sd">    Notes:</span>
<span class="sd">        (x,y) should be accessible like:</span>
<span class="sd">        &gt;&gt;&gt; x_coords = origin_points[:,0]</span>
<span class="sd">        &gt;&gt;&gt; y_coords = origin_points[:,1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">compute_vertex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">),</span> <span class="n">origin_points</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_bin_catalog_spatio_magnitude_counts</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">mags</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">,</span> <span class="n">mag_bins</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly, n_cat) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    Eventually, we can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># index in cartesian grid for events in data. note, this has a different index than the</span>
    <span class="c1"># vector of polygons. this mapping is stored in [:,:,1] index of mask</span>
    <span class="c1"># index in 2d grid</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">binx</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">biny</span><span class="p">)</span>
    <span class="n">mag_idxs</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">mag_bins</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">right_continuous</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># start with zero event counts in each bin</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_poly</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_bins</span><span class="p">)))</span>
    <span class="c1"># does not seem that we can vectorize this part</span>
    <span class="n">skipped</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="ow">and</span> <span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">mag_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># getting spatial bin from mask</span>
            <span class="n">hash_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">mag_idx</span> <span class="o">=</span> <span class="n">mag_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># update event counts in that polygon</span>
            <span class="n">event_counts</span><span class="p">[(</span><span class="n">hash_idx</span><span class="p">,</span> <span class="n">mag_idx</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skipped</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mags</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">event_counts</span><span class="p">,</span> <span class="n">skipped</span>

<span class="k">def</span> <span class="nf">_bin_catalog_spatial_counts</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    We can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span>
    <span class="c1"># will return negative</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>
    <span class="c1"># bin1d returns -1 if outside the region</span>
    <span class="c1"># todo: think about how to change this behavior for less confusions, bc -1 is an actual value that can be chosen</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># this can be memory optimized by keeping short list and storing index, only for case where n/2 events</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_poly</span><span class="p">)</span>
    <span class="c1"># selecting the indexes into polygons correspoding to lons and lats within the grid</span>
    <span class="n">hash_idx</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># aggregate in counts</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">event_counts</span><span class="p">,</span> <span class="n">hash_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">event_counts</span>

<span class="k">def</span> <span class="nf">_bin_catalog_probability</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">n_poly</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">idx_map</span><span class="p">,</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of event counts as ndarray with shape (n_poly) where each value</span>
<span class="sd">    represents the event counts within the polygon.</span>

<span class="sd">    Using [:, :, 1] index of the mask, we store the mapping between the index of n_poly and</span>
<span class="sd">    that polygon in the mask. Additionally, the polygons are ordered such that the index of n_poly</span>
<span class="sd">    in the result corresponds to the index of the polygons.</span>

<span class="sd">    We can make a structure that could contain both of these, but the trade-offs will need</span>
<span class="sd">    to be compared against performance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">binx</span><span class="p">,</span> <span class="n">biny</span>
    <span class="c1"># returns -1 if outside of the bbox</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span>
    <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">event_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_poly</span><span class="p">)</span>
    <span class="c1"># [:,:,1] is a mapping from the polygon array to cartesian grid</span>
    <span class="n">hash_idx</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="o">~</span><span class="n">bad</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># dont accumulate just set to one for probability</span>
    <span class="n">event_counts</span><span class="p">[</span><span class="n">hash_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">event_counts</span>

<div class="viewcode-block" id="Polygon"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.Polygon.html#csep.core.regions.Polygon">[docs]</a><span class="k">class</span> <span class="nc">Polygon</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents polygons defined through a collection of vertices.</span>

<span class="sd">    This polygon is assumed to be 2d, but could contain an arbitrary number of vertices. The path is treated as not being</span>
<span class="sd">    closed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Polygon.__init__"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.Polygon.html#csep.core.regions.Polygon.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="c1"># instance members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># https://matplotlib.org/3.1.1/api/path_api.html</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a bool array which is True if the path contains the corresponding point.</span>

<span class="sd">        Args:</span>
<span class="sd">            points: 2d numpy array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nd_points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nd_points</span> <span class="o">=</span> <span class="n">nd_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">contains_points</span><span class="p">(</span><span class="n">nd_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; return the centroid of the polygon.&quot;&quot;&quot;</span>
        <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">c0</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">c0</span> <span class="o">/</span> <span class="n">k</span><span class="p">,</span> <span class="n">c1</span> <span class="o">/</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">get_xcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_ycoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_great_circle_radius</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a polygon object from a given radius and centroid location.</span>

<span class="sd">        Args:</span>
<span class="sd">            centroid: (lon, lat)</span>
<span class="sd">            radius: should be in (meters)</span>
<span class="sd">            num_points: more points is higher resolution polygon</span>

<span class="sd">        Returns:</span>
<span class="sd">            polygon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geod</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Geod</span><span class="p">(</span><span class="n">ellps</span><span class="o">=</span><span class="s1">&#39;WGS84&#39;</span><span class="p">)</span>
        <span class="n">azim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
        <span class="c1"># create vectors with same length as azim for computations</span>
        <span class="n">center_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span> <span class="o">*</span> <span class="n">radius</span>
        <span class="c1"># get new lons and lats</span>
        <span class="n">endlon</span><span class="p">,</span> <span class="n">endlat</span><span class="p">,</span> <span class="n">backaz</span> <span class="o">=</span> <span class="n">geod</span><span class="o">.</span><span class="n">fwd</span><span class="p">(</span><span class="n">center_lons</span><span class="p">,</span> <span class="n">center_lats</span><span class="p">,</span> <span class="n">azim</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
        <span class="c1"># class method</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">endlon</span><span class="p">,</span> <span class="n">endlat</span><span class="p">]))</span></div>

<div class="viewcode-block" id="CartesianGrid2D"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.CartesianGrid2D.html#csep.core.regions.CartesianGrid2D">[docs]</a><span class="k">class</span> <span class="nc">CartesianGrid2D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents a 2D cartesian gridded region.</span>

<span class="sd">    The class provides functions to query onto an index 2D Cartesian grid and maintains a mapping between space coordinates defined</span>
<span class="sd">    by polygons and the index into the polygon array.</span>

<span class="sd">    Custom regions can be easily created by using the from_polygon classmethod. This function will accept an arbitrary closed</span>
<span class="sd">    polygon and return a CartesianGrid class with only points inside the polygon to be valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CartesianGrid2D.__init__"><a class="viewcode-back" href="../../../reference/generated/csep.core.regions.CartesianGrid2D.html#csep.core.regions.CartesianGrid2D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygons</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;cartesian2d&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span> <span class="o">=</span> <span class="n">polygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dh</span> <span class="o">=</span> <span class="n">dh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_bitmask_vec</span><span class="p">()</span>
        <span class="c1"># in mask, True = bad value and False = good value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># contains the mapping from polygon_index to the mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># index values of polygons array into the 2d cartesian grid, based on the midpoint.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_index_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the index of lons, lats in self.polygons</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: ndarray-like</span>
<span class="sd">            lats: ndarray-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: ndarray-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lats</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one lon and lat pair contain values that are outside of the valid region.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one lon and lat pair contain values that are outside of the valid region.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_location_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the polygon associated with the index idx.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx: index of polygon in region</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polygon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">polys</span>

    <span class="k">def</span> <span class="nf">get_masked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns bool array lons and lats are not included in the spatial region.</span>

<span class="sd">        .. note:: The ordering of lons and lats should correspond to the ordering of the lons and lats in the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            lons: array-like</span>
<span class="sd">            lats: array-like</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx: array-like</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="c1"># handles the case where values are outside of the region</span>
        <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">idy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">idy</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># manually set values outside region</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">bad_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns 2d ndrray representation of the data set, corresponding to the bounding box.</span>

<span class="sd">        Args:</span>
<span class="sd">            data:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">get_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns rectangular bounding box around region. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns midpoints of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">origins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns origins of rectangular polygons in region &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="s1">&#39;dh&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">),</span>
            <span class="s1">&#39;polygons&#39;</span><span class="p">:</span> <span class="p">[{</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">adict</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">adict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Todo!&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_origins</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">magnitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates instance of class from 2d numpy.array of lon/lat origins.</span>

<span class="sd">        Note: Grid spacing should be constant in the entire region. This condition is not explicitly checked for for performance</span>
<span class="sd">        reasons.</span>

<span class="sd">        Args:</span>
<span class="sd">            origins (numpy.ndarray like): [:,0] = lons and [:,1] = lats</span>
<span class="sd">            magnitudes (numpy.array like): optional, if provided will bind magnitude information to the class.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cls</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ensure we can access the lons and lats</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">origins</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">origins</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;origins must be of type numpy.array or be numpy array like.&quot;</span><span class="p">)</span>

        <span class="c1"># dh must be regular, no explicit checking.</span>
        <span class="k">if</span> <span class="n">dh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dh2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lons</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dh1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">dh1</span><span class="p">,</span> <span class="n">dh2</span><span class="p">])</span>

        <span class="n">region</span> <span class="o">=</span> <span class="n">CartesianGrid2D</span><span class="p">([</span><span class="n">Polygon</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">compute_vertices</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">dh</span><span class="p">)],</span> <span class="n">dh</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magnitudes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region</span><span class="o">.</span><span class="n">magnitudes</span> <span class="o">=</span> <span class="n">magnitudes</span>
        <span class="k">return</span> <span class="n">region</span>

    <span class="k">def</span> <span class="nf">_build_bitmask_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        same as build mask but using vectorized calls to bin1d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># build bounding box of set of polygons based on origins</span>
        <span class="n">nd_origins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">origin</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nd_origins</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))]</span>

        <span class="c1"># get midpoints for hashing</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">poly</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">])</span>

        <span class="c1"># set up grid over bounding box</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">cleaner_range</span><span class="p">(</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">)</span>

        <span class="c1"># set up mask array, 1 is index 0 is mask</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># set all indices to nan</span>
        <span class="n">a</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># bin1d returns the index of polygon within the cartesian grid</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">)</span>
        <span class="n">idy</span> <span class="o">=</span> <span class="n">bin1d_vec</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ys</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">)):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># build mask in dim=0; here masked values are 1. see note below.</span>
            <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># note: csep1 gridded forecast file format convention states that a &quot;1&quot; indicates a valid cell, which is the opposite</span>
                    <span class="c1"># of the masking criterion</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">idy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

    <span class="k">def</span> <span class="nf">tight_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># creates tight bounding box around the region, probably a faster way to do this.</span>
        <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">asc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_map</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">argmin</span> <span class="o">=</span> <span class="n">first_nonnan</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">argmax</span> <span class="o">=</span> <span class="n">last_nonnan</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="c1"># points are stored clockwise</span>
            <span class="n">poly_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">argmin</span><span class="p">])]</span><span class="o">.</span><span class="n">points</span>
            <span class="n">asc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">poly_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">asc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">poly_min</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">poly_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygons</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">argmax</span><span class="p">])]</span><span class="o">.</span><span class="n">points</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_max</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># close the loop</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">asc</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;stable&#39;</span><span class="p">)</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">unique_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_poly</span><span class="p">,</span> <span class="p">[</span><span class="n">unique_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unique_poly</span></div>

<span class="k">def</span> <span class="nf">geographical_area_from_bounds</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon2</span><span class="p">,</span><span class="n">lat2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes area of spatial cell identified by origin coordinate and top right cooridnate.</span>
<span class="sd">    The functions computes area only for square/rectangle bounding box by based on spherical earth assumption.</span>
<span class="sd">    Args:</span>
<span class="sd">        lon1,lat1 : Origin coordinates</span>
<span class="sd">        lon2,lat2: Top right coordinates</span>
<span class="sd">    Returns:</span>
<span class="sd">        Area of cell in Km2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">earth_radius_km</span> <span class="o">=</span> <span class="mf">6371.</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="n">earth_radius_km</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">rad_per_deg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0e0</span>

    <span class="n">strip_area_steradian</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0e0</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">90.0e0</span> <span class="o">-</span> <span class="n">lat1</span><span class="p">)</span> <span class="o">*</span> <span class="n">rad_per_deg</span><span class="p">))</span> \
                           <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0e0</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="mf">90.0e0</span> <span class="o">-</span> <span class="n">lat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">rad_per_deg</span><span class="p">))</span>
    <span class="n">area_km2</span> <span class="o">=</span> <span class="n">strip_area_steradian</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">360.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">area_km2</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
 
&#169; 2020, University of Southern California.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.


</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>